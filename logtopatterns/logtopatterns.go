//
// This program is intended to make creating Ignore patterns for logaudit easy.
//
// You provide it a log file, and it attempts to combine all similar log lines
// into one (dropping duplicates, etc). It also replaces pid numbers such as
// dhclient[1966] to dhclient\[\d+\].
//
package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
)

// Args are command line arguments.
type Args struct {
	// LogFile is a path to a log file.
	LogFile string

	// FromLogaudit tells us if the log file is one generated by logaudit or not.
	FromLogaudit bool
}

func main() {
	log.SetFlags(0)

	args, err := getArgs()
	if err != nil {
		os.Exit(1)
	}

	lines, err := readFile(args.LogFile)
	if err != nil {
		log.Fatalf("Unable to read file: %s: %s", args.LogFile, err)
	}

	err = consolidateAndOutput(lines, args.FromLogaudit)
	if err != nil {
		log.Fatal(err)
	}
}

func getArgs() (*Args, error) {
	file := flag.String("file", "", "Path to a log file.")
	fromLogaudit := flag.Bool("from-logaudit", false, "Toggle true if the file is output from logaudit. This means it will have lines prefixed with log filename.")

	flag.Parse()

	if len(*file) == 0 {
		flag.PrintDefaults()
		return nil, fmt.Errorf("You must provide a file.")
	}

	return &Args{
		LogFile:      *file,
		FromLogaudit: *fromLogaudit,
	}, nil
}

func readFile(file string) ([]string, error) {
	fh, err := os.Open(file)
	if err != nil {
		return nil, err
	}

	defer fh.Close()

	scanner := bufio.NewScanner(fh)

	lines := []string{}

	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}

	err = scanner.Err()
	if err != nil {
		return nil, fmt.Errorf("Scanner: %s", err.Error())
	}

	return lines, nil
}

func consolidateAndOutput(lines []string, fromLogaudit bool) error {
	// Lines look like so (syslog):
	// Oct 23 06:31:46 snorri dhclient[1966]: DHCPACK of 192.168.1.3 from 192.168.1.25
	// Strip up to here ------^

	fileToUniqueLines := map[string]map[string]struct{}{}

	logFile := ""

	for _, line := range lines {
		noMatchRe := regexp.MustCompile("^Log \\S+ did not match any configuration\\. Dumping it entirely\\.$")
		if noMatchRe.MatchString(line) {
			continue
		}

		if fromLogaudit {
			pieces := strings.Split(line, " ")
			logFile = pieces[0]
			_, ok := fileToUniqueLines[logFile]
			if !ok {
				fileToUniqueLines[logFile] = map[string]struct{}{}
			}
			line = strings.Join(pieces[1:], " ")
		}

		line = regexp.QuoteMeta(line)

		// Turn kernel: \[    0\.000000\] into kernel: \[\s*\d+\.\d+\]
		// I do this prior to split as note the space inside [] (sometimes).
		kernelRe := regexp.MustCompile("kernel: \\\\\\[\\s*\\d+\\\\\\.\\d+\\\\\\]")
		line = kernelRe.ReplaceAllString(line, "kernel: \\[\\s*\\d+\\.\\d+\\]")

		// Oct 10 15:15:15 and Oct  1 15:15:15 should split the same. Drop the
		// problematic extra space in the second.
		timeRe := regexp.MustCompile("^[A-Za-z]{3}\\s+\\d+")
		// We drop the date currently, so we can replace it with nonsense.
		line = timeRe.ReplaceAllString(line, "xxx 99")

		pieces := strings.Split(line, " ")

		// All digits into \d+
		digitRe := regexp.MustCompile("\\d+")
		for i := range pieces {
			pieces[i] = digitRe.ReplaceAllString(pieces[i], "\\d+")
		}

		strippedLine := strings.Join(pieces[4:], " ")

		fileToUniqueLines[logFile][strippedLine] = struct{}{}
	}

	for logFile, uniqueLines := range fileToUniqueLines {
		sortedLines := []string{}
		for line := range uniqueLines {
			sortedLines = append(sortedLines, line)
		}

		sort.Strings(sortedLines)

		fmt.Printf("FilenamePattern: %s\n", logFile)
		for _, line := range sortedLines {
			fmt.Printf("Ignore: %s\n", line)
		}
	}

	return nil
}
